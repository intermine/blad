// Generated by CoffeeScript 1.3.3
(function() {
  var EE, async, connect, cs, eco, events, fs, mongodb, path, uglify, walk, wrench, write;

  fs = require('fs');

  path = require('path');

  cs = require('coffee-script');

  eco = require('eco');

  uglify = require('uglify-js');

  wrench = require('wrench');

  events = require('events');

  mongodb = require('mongodb');

  async = require('async');

  EE = new events.EventEmitter();

  exports.log = function(cb) {
    return EE.on('log', function(msg) {
      return cb(msg);
    });
  };

  exports.compile = {
    'admin': function(cb) {
      EE.emit('log', 'Compiling Chaplin.js admin client app code');
      return async.waterfall([
        function(_cb) {
          try {
            wrench.mkdirSyncRecursive("" + __dirname + "/../public/admin", 0x1ff);
            return _cb(null);
          } catch (err) {
            return _cb(err);
          }
        }, async.apply(wrench.copyDirRecursive, "" + __dirname + "/../../src/admin/assets", "" + __dirname + "/../public/admin", function(_cb) {
          var canExit, exit, jobs, root, target;
          jobs = 0;
          canExit = false;
          exit = function() {
            if (jobs === 0 && canExit) {
              return _cb(null);
            }
          };
          root = "" + __dirname + "/../../src/admin";
          target = path.resolve("" + __dirname + "/../../build/public/admin/js");
          return wrench.readdirRecursive(root, function(err, files) {
            var file, fns, _fn, _i, _len;
            if (err) {
              return _cb(err);
            }
            if (!files) {
              canExit = true;
              return exit();
            } else {
              jobs++;
              fns = [];
              _fn = function(file) {
                file = root + '/' + file;
                console.log(file);
                if (file.match(/\.eco/)) {
                  return fns.push(function(__cb) {
                    var js, name;
                    name = file.split('/').pop();
                    js = eco.precompile(fs.readFileSync(file, "utf8"));
                    js = (uglify.minify("JST['" + name + "'] = " + js, {
                      'fromString': true
                    })).code;
                    write((target + '/' + file).replace('.eco', '.js'), js);
                    return __cb(null);
                  });
                } else if (file.match(/\.coffee/)) {
                  return fns.push(function(__cb) {
                    var js;
                    js = cs.compile(fs.readFileSync(file, "utf8"), {
                      'bare': 'on'
                    });
                    write((target + '/' + file).replace('.coffee', '.js'), js);
                    return __cb(null);
                  });
                }
              };
              for (_i = 0, _len = files.length; _i < _len; _i++) {
                file = files[_i];
                _fn(file);
              }
              return async.parallel(fns, function(err) {
                if (err) {
                  return _cb(err);
                } else {
                  jobs--;
                  return exit();
                }
              });
            }
          });
        })
      ], cb);
    },
    'forms': function(_arg) {
      var site_src;
      site_src = _arg.site_src;
      return function(cb) {
        EE.emit('log', 'Compiling custom document type forms');
        return walk(path.join(site_src, '/src/types'), function(files) {
          var file, js, name, p, tml, _i, _len;
          tml = [];
          tml.push((uglify.minify("JST['form_BasicDocument.eco'] = " + (eco.precompile("")), {
            'fromString': true
          })).code);
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            if (!(file.match(/form\.eco/))) {
              continue;
            }
            js = eco.precompile(fs.readFileSync(file, "utf-8"));
            p = file.split('/');
            name = p[p.length - 2];
            tml.push((uglify.minify("JST['form_" + name + ".eco'] = " + js, {
              'fromString': true
            })).code);
          }
          write("" + __dirname + "/../public/admin/js/templates/document_forms.js", tml.join("\n"));
          return cb(null);
        });
      };
    }
  };

  exports.copy = {
    'public': function(_arg) {
      var site_src;
      site_src = _arg.site_src;
      return function(cb) {
        EE.emit('log', "Copying site's public files");
        wrench.copyDirSyncRecursive(path.join(site_src, '/src/public'), "" + __dirname + "/../public/site");
        return cb(null);
      };
    }
  };

  exports.include = {
    'presenters': function(_arg) {
      var site_src;
      site_src = _arg.site_src;
      return function(cb) {
        EE.emit('log', 'Returning a list of presenter paths');
        return walk(path.join(site_src, '/src/types'), function(files) {
          var f;
          files = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = files.length; _i < _len; _i++) {
              f = files[_i];
              if (f.match(/presenter\.coffee/)) {
                _results.push(f);
              }
            }
            return _results;
          })();
          return cb(null, files);
        });
      };
    }
  };

  exports.db = {
    'export': function(cfg, dir, done) {
      return async.waterfall([
        function(cb) {
          EE.emit('log', 'Create directory for dump');
          return fs.mkdir("" + dir + "/dump", function(err) {
            if (err && err.code !== 'EEXIST') {
              return cb(err);
            } else {
              return cb(null);
            }
          });
        }, function(cb) {
          return connect(cfg.mongodb, 'documents', cb, function(collection, cb) {
            EE.emit('log', 'Dump the database');
            return collection.find({}, {
              'sort': 'url'
            }).toArray(function(err, docs) {
              if (err) {
                return cb(err);
              } else {
                return cb(docs);
              }
            });
          }, function(docs, cb) {
            EE.emit('log', 'Write file');
            return fs.open("" + dir + "/dump/data.json", 'w', 0x1b6, function(err, id) {
              if (err) {
                return cb(err);
              } else {
                return fs.write(id, JSON.stringify(docs, null, 4), null, 'utf8', function() {
                  return cb(null);
                });
              }
            });
          });
        }
      ], function(err) {
        if (err) {
          try {
            err = JSON.parse(err);
            console.log(err.error.message || err.message || err);
          } catch (e) {
            console.log(err);
          }
          return process.exit();
        } else {
          if (done && typeof done === 'function') {
            return done();
          } else {
            return process.exit();
          }
        }
      });
    },
    'import': function(cfg, dir, done) {
      return async.waterfall([
        function(cb) {
          return connect(cfg.mongodb, 'documents', cb, function(collection, cb) {
            EE.emit('log', 'Read dump file');
            return cb(null, collection, JSON.parse(fs.readFileSync("" + dir + "/dump/data.json", 'utf-8')));
          }, function(collection, docs, cb) {
            EE.emit('log', 'Clear database');
            return collection.remove({}, function(err) {
              if (err) {
                return cb(err);
              } else {
                return cb(null, collection, docs);
              }
            });
          }, function(collection, docs, cb) {
            var doc;
            EE.emit('log', 'Cleanup `_id`');
            return cb(null, collection, (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = docs.length; _i < _len; _i++) {
                doc = docs[_i];
                _results.push((delete doc._id, doc));
              }
              return _results;
            })());
          }, function(collection, docs, cb) {
            EE.emit('log', 'Insert into database');
            return collection.insert(docs, {
              'safe': true
            }, function(err, docs) {
              if (err) {
                return cb(err);
              } else {
                return cb(null);
              }
            });
          });
        }
      ], function(err) {
        if (err) {
          try {
            err = JSON.parse(err);
            console.log(err.error.message || err.message || err);
          } catch (err) {
            console.log(err);
          }
          return process.exit();
        } else {
          if (done && typeof done === 'function') {
            return done();
          } else {
            return process.exit();
          }
        }
      });
    }
  };

  walk = function(path, cb) {
    var results;
    results = [];
    return fs.readdir(path, function(err, list) {
      var pending;
      if (err) {
        throw err;
      }
      pending = list.length;
      if (!pending) {
        return cb(results);
      }
      return list.forEach(function(file) {
        file = "" + path + "/" + file;
        return fs.stat(file, function(err, stat) {
          if (err) {
            throw err;
          }
          if (stat && stat.isDirectory()) {
            return walk(file, function(res) {
              results = results.concat(res);
              if (!--pending) {
                return cb(results);
              }
            });
          } else {
            results.push(file);
            if (!--pending) {
              return cb(results);
            }
          }
        });
      });
    });
  };

  write = function(path, text, mode) {
    var dir, id;
    if (mode == null) {
      mode = "w";
    }
    dir = path.split('/').reverse().slice(1).reverse().join('/');
    wrench.mkdirSyncRecursive(dir, 0x1ff);
    id = fs.openSync(path, mode, 0x1b6);
    return fs.writeSync(id, text, null, "utf8");
  };

  connect = function(uri, collection, cb) {
    EE.emit('log', 'Connect to MongoDB');
    return mongodb.Db.connect(uri, function(err, connection) {
      if (err) {
        return cb(err);
      } else {
        return connection.collection(collection, function(err, coll) {
          if (err) {
            return cb(err);
          } else {
            return cb(null, coll);
          }
        });
      }
    });
  };

}).call(this);

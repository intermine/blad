// Generated by CoffeeScript 1.3.3
(function() {
  var EE, Q, connect, cs, eco, events, fs, mongodb, uglify, walk, wrench, write;

  fs = require('fs');

  cs = require('coffee-script');

  eco = require('eco');

  uglify = require('uglify-js');

  wrench = require('wrench');

  events = require('events');

  mongodb = require('mongodb');

  Q = require('q');

  EE = new events.EventEmitter();

  exports.log = function(cb) {
    return EE.on('log', function(msg) {
      return cb(msg);
    });
  };

  exports.compile = {
    'admin': function() {
      var def;
      EE.emit('log', 'Compiling chaplin admin client code');
      def = Q.defer();
      walk("" + __dirname + "/admin", function(files) {
        var file, js, name, _i, _len;
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          if (file.match(/\.eco/)) {
            name = file.split('/').pop();
            js = eco.precompile(fs.readFileSync(file, "utf-8"));
            js = (uglify.minify("JST['" + name + "'] = " + js, {
              'fromString': true
            })).code;
            write(file.replace('/admin/', '/public/admin/js/').replace('.eco', '.js'), js);
          } else if (file.match(/\.coffee/)) {
            js = cs.compile(fs.readFileSync(file, "utf-8"), {
              'bare': 'on'
            });
            write(file.replace('/admin/', '/public/admin/js/').replace('.coffee', '.js'), js);
          }
        }
        return def.resolve();
      });
      return def.promise;
    },
    'forms': function(dir) {
      var def;
      EE.emit('log', 'Compiling custom document type forms');
      def = Q.defer();
      walk("" + dir + "/src/types", function(files) {
        var file, js, name, p, tml, _i, _len;
        tml = [];
        tml.push((uglify.minify("JST['form_BasicDocument.eco'] = " + (eco.precompile("")), {
          'fromString': true
        })).code);
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          if (!(file.match(/form\.eco/))) {
            continue;
          }
          js = eco.precompile(fs.readFileSync(file, "utf-8"));
          p = file.split('/');
          name = p[p.length - 2];
          tml.push((uglify.minify("JST['form_" + name + ".eco'] = " + js, {
            'fromString': true
          })).code);
        }
        write("" + __dirname + "/public/admin/js/templates/document_forms.js", tml.join("\n"));
        return def.resolve();
      });
      return def.promise;
    }
  };

  exports.copy = {
    'public': function(dir) {
      EE.emit('log', 'Copying site\'s public files');
      return wrench.copyDirSyncRecursive("" + dir + "/src/public", "" + __dirname + "/public/site");
    }
  };

  exports.include = {
    'presenters': function(dir) {
      var def;
      EE.emit('log', 'Returning a list of presenter paths');
      def = Q.defer();
      walk("" + dir + "/src/types", function(files) {
        var f;
        return def.resolve((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            f = files[_i];
            if (f.match(/presenter\.coffee/)) {
              _results.push(f);
            }
          }
          return _results;
        })());
      });
      return def.promise;
    }
  };

  exports.db = {
    'export': function(cfg, dir, done) {
      return ((function() {
        var def;
        EE.emit('log', 'Create directory for dump');
        def = Q.defer();
        fs.mkdir("" + dir + "/dump", function(err) {
          if (err && err.code !== 'EEXIST') {
            return def.reject(err);
          } else {
            return def.resolve();
          }
        });
        return def.promise;
      })()).then(function() {
        return connect(cfg.mongodb, 'documents');
      }).then(function(collection) {
        var def;
        EE.emit('log', 'Dump the database');
        def = Q.defer();
        collection.find({}, {
          'sort': 'url'
        }).toArray(function(err, docs) {
          if (err) {
            return def.reject(err);
          } else {
            return def.resolve(docs);
          }
        });
        return def.promise;
      }).then(function(docs) {
        var def;
        EE.emit('log', 'Write file');
        def = Q.defer();
        fs.open("" + dir + "/dump/data.json", 'w', 0x1b6, function(err, id) {
          if (err) {
            return def.reject(err);
          } else {
            return fs.write(id, JSON.stringify(docs, null, 4), null, 'utf8', function() {
              return def.resolve();
            });
          }
        });
        return def.promise;
      }).done(function() {
        if (done && typeof done === 'function') {
          return done();
        } else {
          return process.exit();
        }
      }, function(err) {
        try {
          err = JSON.parse(err);
          console.log(err.error.message || err.message || err);
        } catch (e) {
          console.log(err);
        }
        return process.exit();
      });
    },
    'import': function(cfg, dir, done) {
      return connect(cfg.mongodb, 'documents').then(function(collection) {
        EE.emit('log', 'Read dump file');
        return [collection, JSON.parse(fs.readFileSync("" + dir + "/dump/data.json", 'utf-8'))];
      }).then(function(_arg) {
        var collection, def, docs;
        collection = _arg[0], docs = _arg[1];
        EE.emit('log', 'Clear database');
        def = Q.defer();
        collection.remove({}, function(err) {
          if (err) {
            return def.reject(err);
          } else {
            return def.resolve([collection, docs]);
          }
        });
        return def.promise;
      }).then(function(_arg) {
        var collection, doc, docs;
        collection = _arg[0], docs = _arg[1];
        EE.emit('log', 'Cleanup `_id`');
        return [
          collection, (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = docs.length; _i < _len; _i++) {
              doc = docs[_i];
              _results.push((delete doc._id, doc));
            }
            return _results;
          })()
        ];
      }).then(function(_arg) {
        var collection, def, docs;
        collection = _arg[0], docs = _arg[1];
        EE.emit('log', 'Insert into database');
        def = Q.defer();
        collection.insert(docs, {
          'safe': true
        }, function(err, docs) {
          if (err) {
            return def.reject(err);
          } else {
            return def.resolve();
          }
        });
        return def.promise;
      }).done(function() {
        if (done && typeof done === 'function') {
          return done();
        } else {
          return process.exit();
        }
      }, function(err) {
        try {
          err = JSON.parse(err);
          console.log(err.error.message || err.message || err);
        } catch (e) {
          console.log(err);
        }
        return process.exit();
      });
    }
  };

  walk = function(path, cb) {
    var results;
    results = [];
    return fs.readdir(path, function(err, list) {
      var pending;
      if (err) {
        throw err;
      }
      pending = list.length;
      if (!pending) {
        return cb(results);
      }
      return list.forEach(function(file) {
        file = "" + path + "/" + file;
        return fs.stat(file, function(err, stat) {
          if (err) {
            throw err;
          }
          if (stat && stat.isDirectory()) {
            return walk(file, function(res) {
              results = results.concat(res);
              if (!--pending) {
                return cb(results);
              }
            });
          } else {
            results.push(file);
            if (!--pending) {
              return cb(results);
            }
          }
        });
      });
    });
  };

  write = function(path, text, mode) {
    var dir, writeFile;
    if (mode == null) {
      mode = "w";
    }
    writeFile = function(path) {
      var id;
      id = fs.openSync(path, mode, 0x1b6);
      return fs.writeSync(id, text, null, "utf8");
    };
    dir = path.split('/').reverse().slice(1).reverse().join('/');
    if (dir !== '.') {
      try {
        fs.mkdirSync(dir, 0x1ff);
      } catch (e) {
        if (e.code !== 'EEXIST') {
          throw e;
        }
      }
      return writeFile(path);
    } else {
      return writeFile(path);
    }
  };

  connect = function(uri, collection) {
    var def;
    EE.emit('log', 'Connect to MongoDB');
    def = Q.defer();
    mongodb.Db.connect(uri, function(err, connection) {
      if (err) {
        return def.reject(err);
      } else {
        return connection.collection(collection, function(err, coll) {
          if (err) {
            return def.reject(err);
          } else {
            return def.resolve(coll);
          }
        });
      }
    });
    return def.promise;
  };

}).call(this);
